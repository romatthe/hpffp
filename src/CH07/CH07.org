#+TITLE: Chapter 7: More Functional Patterns
#+OPTIONS: toc:nil \n:t

* Notes
** Shadowing

We can *shadow* arguments of a function like this:
#+BEGIN_SRC haskell
bindExp :: Integer -> String
bindExp x =
  let x = 10; y = 5 in
    "the integer was: " ++ show x
    ++ " and y was: " ++ show y

Prelude> bindExp 9001
"the integer was: 10 and y was: 5"
#+END_SRC

The definition of x that is innermost in the code (where the function name at the left margin is the outside) takes precedence because Haskell is lexically scoped.
Lexical scoping means that resolving the value for a named entity depends on the location in the code and the lexical context, for example in let and where clauses.
#+BEGIN_SRC haskell
bindExp :: Integer -> String
bindExp x = let x = 10
--     [1]     [2]
                y = 5
            in "x: " ++ show x
--                          [3]
            ++ " y: " ++ show y
#+END_SRC

  1. The parameter x introduced in the definition of bindExp. This gets shadowed by the x in [2].
  2. This is a let-binding of x and shadows the definition of x introduced as an argument at [1].
  3. A use of the x bound by [2]. Given Haskell’s static (lexical) scoping it will always refer to the x defined as x = 10 in the let binding!

** Anonymous Functions:

Haskell allows for succint anonymous function syntax, e.g:
#+BEGIN_SRC haskell
-- Traditional notation:
triple :: Integer -> Integer
triple x = x * 3

-- Anonymous function syntax:
(\x -> x * 3) :: Integer -> Integer
#+END_SRC

** Pattern Matching

Pattern matching is a way of matching values against patterns and, where appropriate, binding variables to successful matches. 
It is worth noting here that patterns can include things as diverse as undefined variables, numeric literals, and list syntax. 
As we will see, pattern matching matches on any and all data constructors.

Example, pattern matching on numbers:
#+BEGIN_SRC haskell
isItTwo :: Integer -> Bool
isItTwo 2 = True
isItTwo _ = False
#+END_SRC
Use of =_= here essentially means, "anything else".

*Note*: Ordering of your patterns matters!
#+BEGIN_SRC haskell
isItTwo :: Integer -> Bool
isItTwo _ = False
isItTwo 2 = True

<interactive>:9:33: Warning:
  Pattern match(es) are overlapped
  In an equation for ‘isItTwo’:
    isItTwo 2 = ...

Prelude> isItTwo 2
False
Prelude> isItTwo 3
False
#+END_SRC

Incomplete pattern matches applied to data they don’t handle will return bottom, a non-value used to denote that the program cannot return a value or result.
This will throw an exception, which if unhandled, will make your program fail.

More importantly, we can pattern match on data constructors. As an example:
#+BEGIN_SRC haskell
newtype Username = Username String
newtype AccountNumber = AccountNumber Integer

data User = UnregisteredUser
          | RegisteredUser Username AccountNumber

printUser :: User -> IO()
printUser UnregisteredUser = putStrLn "UnregisteredUser"
printUser (RegisteredUser (Username name) (AccountNumber acctNum)) = putStrLn $ name ++ " " ++ show acctNum
#+END_SRC

Here's another example:
#+BEGIN_SRC haskell
  data WherePenguinsLive = Galapagos
                         | Antarctica
                         | Australia
                         | SouthAfrica
                         | SouthAmerica
                         deriving (Eq, Show)

  data Penguin = Peng WherePenguinsLive deriving (Eq, Show)

  isSouthAfrica :: WherePenguinsLive -> Bool
  isSouthAfrica SouthAfrica = True
  isSouthAfrica Galapagos = False
  isSouthAfrica Antarctica = False
  isSouthAfrica Australia = False
  isSouthAfrica SouthAmerica = False

  galapagosPenguin :: Penguin -> Bool
  galapagosPenguin (Peng Galapagos) = True
  galapagosPenguin _                = False

  antarcticPenguin :: Penguin -> Bool
  antarcticPenguin (Peng Antarctica) = True
  antarcticPenguin _                 = False

  antarcticOrGalapagosPenguin :: Penguin -> Bool
  antarcticOrGalapagosPenguin p = (galapagosPenguin p) || (antarcticPenguin p)
#+END_SRC

You can also pattern match tuples, like this:
#+BEGIN_SRC haskell
f :: (a, b) -> (c, d) -> ((b, d), (a, c))
f (a, b) (c, d) = ((b, d), (a, c))
#+END_SRC

** Case Expressions

#+BEGIN_SRC haskell
data Bool = False | True
--   [1]     [2]    [3]
#+END_SRC

  1. Type constructor, we only use this in type signatures, not in term-level code like case expressions.
  2. Data constructor for the value of Bool named False — we can match on this.
  3. Data constructor for the value of Bool named True — we can match on this as well.

This:
#+BEGIN_SRC haskell
if x + 1 == 1 then "AWESOME" else "wut"
#+END_SRC
Can be written as:
#+BEGIN_SRC haskell
func x =
  case x + 1 == 1 of
    True -> "AWESOME"
    False -> "wut" 
#+END_SRC

Here's an example with a =where= clause:
#+BEGIN_SRC haskell
pal x =
  case y of
    True -> "yes"
    False -> "no"
  where y = xs == reverse xs
#+END_SRC

* Exercises

** Exercise 1: Grab Bag

   1. Which of these are equivalent?
      a) ~mTh x y z = x * y * z~
      b) ~mTh x y = \z -> x * y * z~
      c) ~mTh x = \y -> \z -> x * y * z~
      d) ~mTh = \x -> \y -> \z -> x * y * z~
      => =a=, =b=, =c= and =d= are equivalent

   2. The type of =mTh= (above) is ~Num a => a -> a -> a -> a~. Which is the type of =mTh 3=?
      => =d=, ~Num a => a -> a -> a~

   3. Anonymous syntax rewrite:
      a) ~where f = \n -> n + 1~
      b) ~addFive = \x y -> (if x > y then y else x) + 5~
      c) ~mflip f x y = f y x~

** Exercise 2: Variety Pack

   1. Given the following declaration:
      #+BEGIN_SRC haskell
      k (x, y) = x
      k1 = k ((4-1), 10)
      k2 = k ("three", (1 + 2))
      k3 = k (3, True)
      #+END_SRC

      a) Type of =k= is ~k :: (a, b) -> a~
      b) Type of =k2= is ~k2 => [Char]~, and is not the same as the other. ~k1~ and ~k3~ are of type ~(Num a) => a~
      c) ~k1~ and ~k3~

   2. Fill in the definition:
      #+BEGIN_SRC haskell
      f :: (a, b, c) -> (d, e, f) -> ((a, d), (c, f))
      f (a, _, c) (d, _, f) = ((a, d), (c, f))  
      #+END_SRC

** Exercise 3: Case Practice

 #+INCLUDE: "~/Source/hpffp/src/CH07/casepractice.hs" src haskell

** Exercise 4: Artful Dodgy

Given the following:
#+BEGIN_SRC haskell
dodgy x y = x + y * 10
oneIsOne = dodgy 1
oneIsTwo = (flip dodgy) 2
#+END_SRC

What is the result of the following?

  1. ~dodgy 1 0~
     Result: ~1~

  2. ~dodgy 1 1~
     Result: ~11~

  3. ~dodgy 2 2~
     Result: ~22~

  4. ~dodgy 1 2~
     Result: ~21~

  5. ~dodgy 2 1~
     Result: ~12~

  6. ~oneIsOne 1~
     Result: ~11~

  7. ~oneIsOne 2~
     Result: ~21~

  8. ~oneIsTwo 1~
     Result: ~21~

  9. ~oneIsTwo 2~
     Result: ~22~

  10. ~oneIsOne 3~
      Result: ~31~

  11. ~oneIsTwo 3~
      Result: ~23~
