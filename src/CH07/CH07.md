
# Notes

## Shadowing

We can **shadow** arguments of a function like this:  

```haskell
bindExp :: Integer -> String
bindExp x =
  let x = 10; y = 5 in
    "the integer was: " ++ show x
    ++ " and y was: " ++ show y

Prelude> bindExp 9001
"the integer was: 10 and y was: 5"
```

The definition of x that is innermost in the code (where the function name at the left margin is the outside) takes precedence because Haskell is lexically scoped.  
Lexical scoping means that resolving the value for a named entity depends on the location in the code and the lexical context, for example in let and where clauses.  

```haskell
bindExp :: Integer -> String
bindExp x = let x = 10
--     [1]     [2]
                y = 5
            in "x: " ++ show x
--                          [3]
            ++ " y: " ++ show y
```

1.  The parameter x introduced in the definition of bindExp. This gets shadowed by the x in [2].
2.  This is a let-binding of x and shadows the definition of x introduced as an argument at [1].
3.  A use of the x bound by [2]. Given Haskell’s static (lexical) scoping it will always refer to the x defined as x = 10 in the let binding!

## Anonymous Functions:

Haskell allows for succint anonymous function syntax, e.g:  

```haskell
-- Traditional notation:
triple :: Integer -> Integer
triple x = x * 3

-- Anonymous function syntax:
(\x -> x * 3) :: Integer -> Integer
```

## Pattern Matching

Pattern matching is a way of matching values against patterns and, where appropriate, binding variables to successful matches.  
It is worth noting here that patterns can include things as diverse as undefined variables, numeric literals, and list syntax.  
As we will see, pattern matching matches on any and all data constructors.  

Example, pattern matching on numbers:  

```haskell
isItTwo :: Integer -> Bool
isItTwo 2 = True
isItTwo _ = False
```

Use of `_` here essentially means, "anything else".  

**Note**: Ordering of your patterns matters!  

```haskell
isItTwo :: Integer -> Bool
isItTwo _ = False
isItTwo 2 = True

<interactive>:9:33: Warning:
  Pattern match(es) are overlapped
  In an equation for ‘isItTwo’:
    isItTwo 2 = ...

Prelude> isItTwo 2
False
Prelude> isItTwo 3
False
```

Incomplete pattern matches applied to data they don’t handle will return bottom, a non-value used to denote that the program cannot return a value or result.  
This will throw an exception, which if unhandled, will make your program fail.  

More importantly, we can pattern match on data constructors. As an example:  

```haskell
newtype Username = Username String
newtype AccountNumber = AccountNumber Integer

data User = UnregisteredUser
          | RegisteredUser Username AccountNumber

printUser :: User -> IO()
printUser UnregisteredUser = putStrLn "UnregisteredUser"
printUser (RegisteredUser (Username name) (AccountNumber acctNum)) = putStrLn $ name ++ " " ++ show acctNum
```

Here's another example:  

```haskell
data WherePenguinsLive = Galapagos
                       | Antarctica
                       | Australia
                       | SouthAfrica
                       | SouthAmerica
                       deriving (Eq, Show)

data Penguin = Peng WherePenguinsLive deriving (Eq, Show)

isSouthAfrica :: WherePenguinsLive -> Bool
isSouthAfrica SouthAfrica = True
isSouthAfrica Galapagos = False
isSouthAfrica Antarctica = False
isSouthAfrica Australia = False
isSouthAfrica SouthAmerica = False

galapagosPenguin :: Penguin -> Bool
galapagosPenguin (Peng Galapagos) = True
galapagosPenguin _                = False

antarcticPenguin :: Penguin -> Bool
antarcticPenguin (Peng Antarctica) = True
antarcticPenguin _                 = False

antarcticOrGalapagosPenguin :: Penguin -> Bool
antarcticOrGalapagosPenguin p = (galapagosPenguin p) || (antarcticPenguin p)
```

You can also pattern match tuples, like this:  

```haskell
f :: (a, b) -> (c, d) -> ((b, d), (a, c))
f (a, b) (c, d) = ((b, d), (a, c))
```

## Case Expressions

```haskell
data Bool = False | True
--   [1]     [2]    [3]
```

1.  Type constructor, we only use this in type signatures, not in term-level code like case expressions.
2.  Data constructor for the value of Bool named False — we can match on this.
3.  Data constructor for the value of Bool named True — we can match on this as well.

This:  

```haskell
if x + 1 == 1 then "AWESOME" else "wut"
```

Can be written as:  

```haskell
func x =
  case x + 1 == 1 of
    True -> "AWESOME"
    False -> "wut" 
```

Here's an example with a `where` clause:  

```haskell
pal x =
  case y of
    True -> "yes"
    False -> "no"
  where y = xs == reverse xs
```

# Exercises

## Exercise 1: Grab Bag

1.  Which of these are equivalent?  
    a) `mTh x y z = x * y * z`  
    b) `mTh x y = \z -> x * y * z`  
    c) `mTh x = \y -> \z -> x * y * z`  
    d) `mTh = \x -> \y -> \z -> x * y * z`  
    `> =a`, `b`, `c` and `d` are equivalent

2.  The type of `mTh` (above) is `Num a => a -> a -> a -> a`. Which is the type of `mTh 3`?  
    `> =d`, `Num a => a -> a -> a`

3.  Anonymous syntax rewrite:  
    a) `where f = \n -> n + 1`  
    b) `addFive = \x y -> (if x > y then y else x) + 5`  
    c) `mflip f x y = f y x`

## Exercise 2: Variety Pack

1.  Given the following declaration:  
    
    ```haskell
    k (x, y) = x
    k1 = k ((4-1), 10)
    k2 = k ("three", (1 + 2))
    k3 = k (3, True)
    ```
    
    a) Type of `k` is `k :: (a, b) -> a`  
    b) Type of `k2` is `k2 => [Char]`, and is not the same as the other. `k1` and `k3` are of type `(Num a) => a`  
    c) `k1` and `k3`

2.  Fill in the definition:  
    
    ```haskell
    f :: (a, b, c) -> (d, e, f) -> ((a, d), (c, f))
    f (a, _, c) (d, _, f) = ((a, d), (c, f))  
    ```

## Exercise 3: Case Practice

```haskell
module CasePractice where

-- Exercise 1
functionC x y = if (x > y) then x else y

functionC' x y =
  case greater x y of
    True -> x
    False -> y
  where greater x y = x > y

-- Exercise 2
ifEvenAdd2 n = if even n then (n + 2) else n

ifEvenAdd2' n =
  case even n of
    True -> n + 2
    False -> n

-- Exercise 3
nums x =
  case compare x 0 of
    LT -> -1
    GT -> 1
    EQ -> 0
```

## Exercise 4: Artful Dodgy

Given the following:  

```haskell
dodgy x y = x + y * 10
oneIsOne = dodgy 1
oneIsTwo = (flip dodgy) 2
```

What is the result of the following?  

1.  `dodgy 1 0`  
    Result: `1`

2.  `dodgy 1 1`  
    Result: `11`

3.  `dodgy 2 2`  
    Result: `22`

4.  `dodgy 1 2`  
    Result: `21`

5.  `dodgy 2 1`  
    Result: `12`

6.  `oneIsOne 1`  
    Result: `11`

7.  `oneIsOne 2`  
    Result: `21`

8.  `oneIsTwo 1`  
    Result: `21`

9.  `oneIsTwo 2`  
    Result: `22`

10. `oneIsOne 3`  
    Result: `31`

11. `oneIsTwo 3`  
    Result: `23`
